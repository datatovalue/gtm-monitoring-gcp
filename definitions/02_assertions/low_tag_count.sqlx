config {
  type: "table", 
  schema: "assertions",
  description: "Checking if tag execution count is above threshold by tag_id with time/day exclusions and timezone support",
  dependencies: ["assertion_logs"],
  tags: ["assertions"],
  disabled: !require("includes/config.js").ASSERTIONS.low_tag_count.enabled
}

select
  'running assertion' as placeholder

pre_operations {
  -- declare variables and default values
  declare assertion string default 'low_tag_count_check';
  declare check int64;
  declare expectation int64 default 0;
  declare sample string;
  declare assertion_status string default 'pass';
  declare error_msg string default 'all tag counts above thresholds';
  declare time_interval string default '${config.ASSERTIONS.low_tag_count.time_interval || "1 hour"}';
  declare passing_tags string;
  declare total_expected_tags int64;
  declare total_configured_tags int64;
  declare current_timezone_datetime datetime;
  declare current_timezone_time time;
  declare current_day_of_week int64;
  declare timezone_info string default '${config.ASSERTIONS.low_tag_count.timezone || "UTC"}';
  declare should_skip boolean default false;
  declare skip_reason string;
  
  -- get current datetime, time, and day of week in the configured timezone
  set current_timezone_datetime = datetime(current_timestamp(), timezone_info);
  set current_timezone_time = time(current_timezone_datetime);
  set current_day_of_week = extract(dayofweek from current_timezone_datetime);
  
  -- check if current day should be excluded (1=Sunday, 7=Saturday)
  ${config.ASSERTIONS.low_tag_count.exclude_days?.length > 0 ? `
  if current_day_of_week in (${config.ASSERTIONS.low_tag_count.exclude_days.join(', ')}) then
    set should_skip = true;
    set skip_reason = format('excluded day (day %d)', current_day_of_week);
  end if;` : '-- no day exclusions configured'}
  
  -- check if we're currently in any excluded time range (only if not already skipped)
  if not should_skip then
    ${config.ASSERTIONS.low_tag_count.exclude_time_ranges?.length > 0 ? 
      config.ASSERTIONS.low_tag_count.exclude_time_ranges.map(range => {
        const startTime = range.start_time;
        const endTime = range.end_time;
        
        // Handle ranges that cross midnight vs same-day ranges
        const condition = startTime > endTime 
          ? `current_timezone_time >= parse_time('%T', '${startTime}') or current_timezone_time < parse_time('%T', '${endTime}')`
          : `current_timezone_time >= parse_time('%T', '${startTime}') and current_timezone_time < parse_time('%T', '${endTime}')`;
        
        return `
    if ${condition} then
      set should_skip = true;
      set skip_reason = 'excluded time range';
    end if;`;
      }).join(''): 
      '-- no time exclusions configured'
    }
  end if;
  
  if should_skip then
    set assertion_status = 'skipped';
    set error_msg = format('Assertion skipped - %s. Current time: %s (%s timezone, day %d)${
      config.ASSERTIONS.low_tag_count.exclude_days?.length > 0 || config.ASSERTIONS.low_tag_count.exclude_time_ranges?.length > 0 ? 
        '. Exclusions: ' + 
        (config.ASSERTIONS.low_tag_count.exclude_days?.length > 0 ? 
          'days [' + config.ASSERTIONS.low_tag_count.exclude_days.join(', ') + ']' : '') +
        (config.ASSERTIONS.low_tag_count.exclude_days?.length > 0 && config.ASSERTIONS.low_tag_count.exclude_time_ranges?.length > 0 ? ', ' : '') +
        (config.ASSERTIONS.low_tag_count.exclude_time_ranges?.length > 0 ? 
          'times [' + config.ASSERTIONS.low_tag_count.exclude_time_ranges.map(r => r.start_time + '-' + r.end_time).join(', ') + ']' : '') : 
        ''}', 
                          skip_reason,
                          format_time('%T', current_timezone_time),
                          timezone_info,
                          current_day_of_week);
    
    -- log the skip
    insert into ${ref("assertion_logs")} (
      inserted_at,
      assertion_name,
      table_name,
      expectation,
      count,
      sample,
      assertion_status,
      error_msg
    )
    values (
      current_timestamp(),
      assertion,
      '${ref("stg_gtm_tag_logs")}',
      expectation,
      0,
      'skipped',
      assertion_status,
      error_msg
    );
    
  else
    -- run normal assertion logic only during active hours/days
    set
      (check, sample, passing_tags, total_expected_tags, total_configured_tags) = (
        select
          as struct 
          countif(status = 'fail') as failed_tags,
          string_agg(
            case 
              when status = 'fail' 
              then format("%s [ID:%s]: %d/%d (%s)%s", 
                         description,
                         tag_id,
                         tag_count, 
                         expected_count,
                         failure_reason,
                         case when status_filter != 'all' 
                              then format(" [%s only]", status_filter)
                              else '' 
                         end)
              else null 
            end, 
            "; "
            order by (expected_count - tag_count) desc  -- worst failures first
          ) as failed_breakdown,
          string_agg(
            case 
              when status = 'pass' 
              then format("%s [ID:%s]: %d/%d âœ“%s", 
                         description,
                         tag_id,
                         tag_count, 
                         expected_count,
                         case when status_filter != 'all' 
                              then format(" [%s]", status_filter)
                              else '' 
                         end)
              else null 
            end, 
            "; "
          ) as passed_breakdown,
          sum(expected_count) as total_expected,
          count(*) as total_configured
        from (
          ${helpers.generateTagCountQueryWithThresholds(ref('stg_gtm_tag_logs'), config.ASSERTIONS.low_tag_count)}
        )
      );
        
    if check > expectation then
      set assertion_status = 'fail';
      set error_msg = format(
        "%d of %d tag IDs failed thresholds in last %s (%s timezone, day %d). Failed: [%s]%s", 
        check, 
        total_configured_tags,
        time_interval,
        timezone_info,
        current_day_of_week,
        coalesce(sample, 'none'),
        case 
          when passing_tags is not null 
          then format(". Passing: [%s]", passing_tags)
          else ''
        end
      );
    else 
      set error_msg = format(
        "All %d tag IDs above thresholds in last %s (%s timezone, day %d)%s", 
        total_configured_tags,
        time_interval,
        timezone_info,
        current_day_of_week,
        case 
          when passing_tags is not null 
          then format(". Details: [%s]", passing_tags)
          else ''
        end
      );
    end if;
      
    -- log assertions with enhanced sample data
    insert into ${ref("assertion_logs")} (
      inserted_at,
      assertion_name,
      table_name,
      expectation,
      count,
      sample,
      assertion_status,
      error_msg
    )
    values (
      current_timestamp(),
      assertion,
      '${ref("stg_gtm_tag_logs")}',
      expectation,
      check,
      coalesce(sample, passing_tags),  -- store either failed or passed tags as sample
      assertion_status,
      error_msg
    );

  end if;
}

post_operations {
  drop table ${self()};
    
  -- raise error only if assertion actually failed (not skipped)
  if assertion_status = 'fail' then
    raise using message = error_msg;
  end if
}